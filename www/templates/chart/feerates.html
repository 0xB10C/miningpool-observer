
<script src="/static/js/d3.v6.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>

<script>

const Y_MIN = 1 - 1 * 0.15

var margin = ({top: 10, right: 15, bottom: 40, left: 50})
//var width = 1200;
//var height = 4000;

var x = function(d) { return d[0]; };
var y = function(d) { return d[1]; };

var canvasDiv = d3.select("#feerate-chart")

var width = canvasDiv.node().clientWidth
var height = canvasDiv.node().clientHeight

var canvas = canvasDiv
  .append('canvas')
  .attr('width', width)
  .attr('height', 0); // we calculate this later on

var context = canvas.node().getContext('2d');

var block = null
var template = null

const ROW_HEIGHT = 8 // pixel
const ROW_WIDTH = width // pixel
const PADDING = 2 // pixel
const SCALE_FACTOR = 8

const BLOCK_WEIGHT = 4_000_000;

function calc_rects(tx_data, feerate_data) {
    const max_feerate = Math.max(...feerate_data)
    const max_feerate_log = Math.log10(max_feerate)

    let rect_list = [];
    let row = 0;
    let row_pos = 0;
    let weight_sum = 0;
    for(const i in tx_data) {
      let feerate = feerate_data[i];
      let color = d3.interpolateWarm(
        (max_feerate_log - Math.log10(feerate)) / max_feerate_log
      )

      let tx_size = tx_data[i];
      weight_sum += tx_size;
      let size = Math.floor(tx_size / ROW_HEIGHT / SCALE_FACTOR);

      if (row_pos + size < ROW_WIDTH) {
        rect_list.push({x: row_pos, y: row * (ROW_HEIGHT+PADDING), width: size, height: ROW_HEIGHT, color: color})
        row_pos += size + PADDING
      } else if (row_pos + size > ROW_WIDTH) {
        let remaining_size = size
        let remaining_row_space = ROW_WIDTH - row_pos;
        // fill current row
        rect_list.push({x: row_pos, y: row * (ROW_HEIGHT+PADDING), width: remaining_row_space, height: ROW_HEIGHT, color: color})
        remaining_size =- remaining_row_space
        row_pos = 0
        row += 1
        while (remaining_size > ROW_WIDTH) {
          // fill the row
          rect_list.push({x: row_pos, y: row * (ROW_HEIGHT+PADDING), width: ROW_WIDTH, height: ROW_HEIGHT, color: color})
          remaining_size =- ROW_WIDTH
          row_pos = 0
          row += 1
        }
        rect_list.push({x: row_pos, y: row * (ROW_HEIGHT+PADDING), width: remaining_size, height: ROW_HEIGHT, color: color})
        row_pos = remaining_size + PADDING
      }
  }
  let rows = row;
  if (row_pos > 0) {
    rows++
  }
  console.log(weight_sum)
  return {rows: row, rects: rect_list}
}

function draw(tx_data, feerate_data) {
  let rects_info = calc_rects(tx_data, feerate_data)
  let height = rects_info.rows * (ROW_HEIGHT+PADDING)
  console.log("height", height, rects_info)
  canvas.attr("height", height)

  context.fillStyle = '#000';
  context.fillRect(0, 0, width, height);
  for(i in rects_info.rects) {
    let rect = rects_info.rects[i]
    context.fillStyle = rect["color"];
    context.fillRect(rect["x"], rect["y"], rect["width"], rect["height"])
  }

}



const zip = (a, b) => a.map((k, i) => [k, b[i]]);

let template_data = zip(template_pkg_weights, template_pkg_feerates)
let block_data = zip(block_pkg_weights, block_pkg_feerates)

draw(
    block_pkg_weights,
    block_pkg_feerates
);

</script>
